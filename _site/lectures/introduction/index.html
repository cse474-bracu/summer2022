<!DOCTYPE html><html lang="en-US"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="/assets/css/just-the-docs-default.css"> <script type="text/javascript" src="/assets/js/vendor/lunr.min.js"></script> <script type="text/javascript" src="/assets/js/just-the-docs.js"></script><meta name="viewport" content="width=device-width, initial-scale=1"><title>Introduction | CSE474</title><meta name="generator" content="Jekyll v3.9.0" /><meta property="og:title" content="Introduction" /><meta name="author" content="Meem Arafat Manab" /><meta property="og:locale" content="en_US" /><meta name="description" content="Simulation methods, model building, random number generator, statistical analysis of results, validation and verification techniques." /><meta property="og:description" content="Simulation methods, model building, random number generator, statistical analysis of results, validation and verification techniques." /><link rel="canonical" href="http://localhost:4000/lectures/introduction/" /><meta property="og:url" content="http://localhost:4000/lectures/introduction/" /><meta property="og:site_name" content="CSE474" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Introduction" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"Meem Arafat Manab"},"headline":"Introduction","description":"Simulation methods, model building, random number generator, statistical analysis of results, validation and verification techniques.","url":"http://localhost:4000/lectures/introduction/","@type":"WebPage","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/assets/images/bracu_logo.png"},"name":"Meem Arafat Manab"},"@context":"https://schema.org"}</script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "AMS" }, } }); </script> <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><body> <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> <symbol id="svg-link" viewBox="0 0 24 24"><title>Link</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"><title>Search</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"><title>Menu</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"><title>Expand</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"><polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"><title>Document</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> </svg><div class="side-bar"><div class="site-header"> <a href="http://localhost:4000/" class="site-title lh-tight"><div class="site-logo"></div></a> <a href="#" id="menu-button" class="site-button"> <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg> </a></div><nav role="navigation" aria-label="Main" id="site-nav" class="site-nav"><ul class="nav-list"><li class="nav-list-item"><a href="http://localhost:4000/" class="nav-list-link">Home</a><li class="nav-list-item active"><a href="http://localhost:4000/lectures/" class="nav-list-link">Lectures</a><li class="nav-list-item"><a href="http://localhost:4000/paper-reviews/" class="nav-list-link">Paper Reviews</a><li class="nav-list-item"><a href="http://localhost:4000/projects/" class="nav-list-link">Final Projects</a><li class="nav-list-item"><a href="http://localhost:4000/resources/" class="nav-list-link">Resources</a></ul></nav><footer class="site-footer"> This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll.</footer></div><div class="main" id="top"><div id="main-header" class="main-header"><div class="search"><div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search CSE474" aria-label="Search CSE474" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label></div><div id="search-results" class="search-results"></div></div></div><div id="main-content-wrap" class="main-content-wrap"><nav aria-label="Breadcrumb" class="breadcrumb-nav"><ol class="breadcrumb-nav-list"><li class="breadcrumb-nav-list-item"><a href="http://localhost:4000/lectures/">Lectures</a><li class="breadcrumb-nav-list-item"><span>Introduction</span></ol></nav><div id="main-content" class="main-content" role="main"> \[\newcommand{\sV}{\mathcal{V}} \newcommand{\nl}[1]{\textsf{#1}} \newcommand{\generate}[1]{\stackrel{#1}{\rightsquigarrow}}\]<p>Welcome to CS324! This is a new course on understanding and developing <strong>large language models</strong>.</p><ol><li><a href="#what-is-a-language-model">What is a language model?</a><li><a href="#a-brief-history">A brief history</a><li><a href="#why-does-this-course-exist">Why does this course exist?</a><li><a href="#structure-of-this-course">Structure of this course</a></ol><h2 id="what-is-a-language-model"> <a href="#what-is-a-language-model" class="anchor-heading" aria-labelledby="what-is-a-language-model"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> What is a language model?</h2><p>The classic definition of a language model (LM) is a <strong>probability distribution over sequences of tokens</strong>. Suppose we have a <strong>vocabulary</strong> \(\sV\) of a set of tokens. A language model \(p\) assigns each sequence of tokens \(x_1, \dots, x_L \in \sV\) a probability (a number between 0 and 1):</p>\[p(x_1, \dots, x_L).\]<p>The probability intuitively tells us how “good” a sequence of tokens is. For example, if the vocabulary is \(\sV = \{ \nl{ate}, \nl{ball}, \nl{cheese}, \nl{mouse}, \nl{the} \}\), the language model might assign (<a href="http://crfm-models.stanford.edu/static/index.html?prompt=%24%7Bprompt%7D&amp;settings=echo_prompt%3A%20true%0Amax_tokens%3A%200&amp;environments=prompt%3A%20%5Bthe%20mouse%20ate%20the%20cheese%2C%20the%20cheese%20ate%20the%20mouse%2C%20mouse%20the%20the%20cheese%20ate%5D">demo</a>):</p>\[p(\nl{the}, \nl{mouse}, \nl{ate}, \nl{the}, \nl{cheese}) = 0.02,\] \[p(\nl{the}, \nl{cheese}, \nl{ate}, \nl{the}, \nl{mouse}) = 0.01,\] \[p(\nl{mouse}, \nl{the}, \nl{the}, \nl{cheese}, \nl{ate}) = 0.0001.\]<p>Mathematically, a language model is a very simple and beautiful object. But the simplicity is deceiving: the ability to assign (meaningful) probabilities to all sequences requires extraordinary (but <em>implicit</em>) linguistic abilities and world knowledge.</p><p>For example, the LM should assign \(\nl{mouse the the cheese ate}\) a very low probability implicitly because it’s ungrammatical (<strong>syntactic knowledge</strong>). The LM should assign \(\nl{the mouse ate the cheese}\) higher probability than \(\nl{the cheese ate the mouse}\) implicitly because of <strong>world knowledge</strong>: both sentences are the same syntactically, but they differ in semantic plausibility.</p><p><strong>Generation</strong>. As defined, a language model \(p\) takes a sequence and returns a probability to assess its goodness. We can also generate a sequence given a language model. The purest way to do this is to sample a sequence \(x_{1:L}\) from the language model \(p\) with probability equal to \(p(x_{1:L})\), denoted:</p>\[x_{1:L} \sim p.\]<p>How to do this computationally efficiently depends on the form of the language model \(p\). In practice, we do not generally sample directly from a language model both because of limitations of real language models and because we sometimes we wish to obtain not an “average” sequence but something closer to the “best” sequence.</p><h3 id="autoregressive-language-models"> <a href="#autoregressive-language-models" class="anchor-heading" aria-labelledby="autoregressive-language-models"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Autoregressive language models</h3><p>A common way to write the joint distribution \(p(x_{1:L})\) of a sequence \(x_{1:L}\) is using the <strong>chain rule of probability</strong>:</p>\[p(x_{1:L}) = p(x_1) p(x_2 \mid x_1) p(x_3 \mid x_1, x_2) \cdots p(x_L \mid x_{1:L-1}) = \prod_{i=1}^L p(x_i \mid x_{1:i-1}).\]<p>For example (<a href="http://crfm-models.stanford.edu/static/index.html?prompt=the%20mouse%20ate%20the%20cheese&amp;settings=echo_prompt%3A%20true%0Amax_tokens%3A%200%0Atop_k_per_token%3A%2010&amp;environments=">demo</a>):</p>\[\begin{align*} p(\nl{the}, \nl{mouse}, \nl{ate}, \nl{the}, \nl{cheese}) = \, &amp; p(\nl{the}) \\ &amp; p(\nl{mouse} \mid \nl{the}) \\ &amp; p(\nl{ate} \mid \nl{the}, \nl{mouse}) \\ &amp; p(\nl{the} \mid \nl{the}, \nl{mouse}, \nl{ate}) \\ &amp; p(\nl{cheese} \mid \nl{the}, \nl{mouse}, \nl{ate}, \nl{the}). \end{align*}\]<p>In particular, \(p(x_i \mid x_{1:i-1})\) is a <strong>conditional probability distribution</strong> of the next token \(x_i\) given the previous tokens \(x_{1:i-1}\).</p><p>Of course, any joint probability distribution can be written this way mathematically, but an <strong>autoregressive language model</strong> is one where each conditional distribution \(p(x_i \mid x_{1:i-1})\) can be computed efficiently (e.g., using a feedforward neural network).</p><p><strong>Generation</strong>. Now to generate an entire sequence \(x_{1:L}\) from an autoregressive language model \(p\), we sample one token at a time given the tokens generated so far:</p>\[\text{for } i = 1, \dots, L: \\ \hspace{1in} x_i \sim p(x_i \mid x_{1:i-1})^{1/T},\]<p>where \(T \ge 0\) is a <strong>temperature</strong> parameter that controls how much randomness we want from the language model:</p><ul><li>\(T = 0\): deterministically choose the highest probable token \(x_i\) at each position \(i\)<li>\(T = 1\): sample “normally” from the pure language model<li>\(T = \infty\): sample from a uniform distribution over the entire vocabulary \(\sV\)</ul><p>However, if we just raise the probabilities to the power \(1/T\), the probability distribution may not sum to 1. We can fix this by re-normalizing the distribution. We call the normalized version \(p_T(x_i \mid x_{1:i-1}) \propto p(x_i \mid x_{1:i-1})^{1/T}\) the <strong>annealed</strong> conditional probability distribution. For example:</p>\[p(\nl{cheese}) = 0.4, \quad\quad\quad p(\nl{mouse}) = 0.6\] \[p_{T=0.5}(\nl{cheese}) = 0.31, \quad\quad\quad p_{T=0.5}(\nl{mouse}) = 0.69\] \[p_{T=0.2}(\nl{cheese}) = 0.12, \quad\quad\quad p_{T=0.2}(\nl{mouse}) = 0.88\] \[p_{T=0}(\nl{cheese}) = 0, \quad\quad\quad p_{T=0}(\nl{mouse}) = 1\]<p><em>Aside</em>: Annealing is a reference to metallurgy, where hot materials are cooled gradually, and shows up in sampling and optimization algorithms such as simulated annealing.</p><p><em>Technical note</em>: sampling iteratively with a temperature \(T\) parameter applied to each conditional distribution \(p(x_i \mid x_{1:i-1})^{1/T}\) is not equivalent (except when \(T = 1\)) to sampling from the annealed distribution over length \(L\) sequences.</p><p><strong>Conditional generation</strong>. More generally, we can perform conditional generation by specifying some a prefix sequence \(x_{1:i}\) (called a <strong>prompt</strong>) and sampling the rest \(x_{i+1:L}\) (called the <strong>completion</strong>). For example, generating with \(T=0\) produces (<a href="http://crfm-models.stanford.edu/static/index.html?prompt=the%20mouse%20ate&amp;settings=temperature%3A%200%0Amax_tokens%3A%202%0Atop_k_per_token%3A%2010%0Anum_completions%3A%2010&amp;environments=">demo</a>):</p>\[\underbrace{\nl{the}, \nl{mouse}, \nl{ate}}_\text{prompt} \generate{T=0} \underbrace{\nl{the}, \nl{cheese}}_\text{completion}.\]<p>If we change the temperature to \(T = 1\), we can get more variety (<a href="http://crfm-models.stanford.edu/static/index.html?prompt=the%20mouse%20ate&amp;settings=temperature%3A%201%0Amax_tokens%3A%202%0Atop_k_per_token%3A%2010%0Anum_completions%3A%2010&amp;environments=">demo</a>), for example, \(\nl{its house}\) and \(\nl{my homework}\).</p><p>As we’ll see shortly, conditional generation unlocks the ability for language models to solve a variety of tasks by simply changing the prompt.</p><h3 id="summary"> <a href="#summary" class="anchor-heading" aria-labelledby="summary"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Summary</h3><ul><li>A language model is a probability distribution \(p\) over sequences \(x_{1:L}\).<li>Intuitively, a good language model should have linguistic capabilities and world knowledge.<li>An autoregressive language model allows for efficient generation of a completion \(x_{i+1:L}\) given a prompt \(x_{1:i}\).<li>The temperature can be used to control the amount of variability in generation.</ul><h2 id="a-brief-history"> <a href="#a-brief-history" class="anchor-heading" aria-labelledby="a-brief-history"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> A brief history</h2><h3 id="information-theory-entropy-of-english-n-gram-models"> <a href="#information-theory-entropy-of-english-n-gram-models" class="anchor-heading" aria-labelledby="information-theory-entropy-of-english-n-gram-models"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Information theory, entropy of English, n-gram models</h3><p><strong>Information theory</strong>. Language models date back to Claude Shannon, who founded information theory in 1948 with his seminal paper, <a href="https://dl.acm.org/doi/pdf/10.1145/584091.584093">A Mathematical Theory of Communication</a>. In this paper, he introduced the <strong>entropy</strong> of a distribution as</p>\[H(p) = \sum_x p(x) \log \frac{1}{p(x)}.\]<p>The entropy which measures the expected number of bits <strong>any algorithm</strong> needs to encode (compress) a sample \(x \sim p\) into a bitstring:</p>\[\nl{the mouse ate the cheese} \Rightarrow 0001110101.\]<ul><li>The lower the entropy, the more “structured” the sequence is, and the shorter the code length.<li>Intuitively, \(\log \frac{1}{p(x)}\) is the length of the code used to represent an element \(x\) that occurs with probability \(p(x)\).<li>If \(p(x) = \frac{1}{8}\), we should allocate \(\log_2(8) = 3\) bits (equivalently, \(\log(8) = 2.08\) nats).</ul><p><em>Aside</em>: actually achieving the Shannon limit is non-trivial (e.g., LDPC codes) and is the topic of coding theory.</p><p><strong>Entropy of English</strong>. Shannon was particularly interested in measuring the entropy of English, represented as a sequence of letters. This means we imagine that there is “true” distribution \(p\) out there (the existence of this is questionable, but it’s still a useful mathematical abstraction), that can spout out samples of English text \(x \sim p\).</p><p>Shannon also defined <strong>cross entropy</strong>:</p>\[H(p, q) = \sum_x p(x) \log \frac{1}{q(x)},\]<p>which measures the expected number of bits (nats) needed to encode a sample \(x \sim p\) using the compression scheme given by the model \(q\) (representing \(x\) with a code of length \(\frac{1}{q(x)}\)).</p><p><strong>Estimating entropy via language modeling</strong>. A crucial property is that the cross entropy \(H(p, q)\) upper bounds the entropy \(H(p)\),</p>\[H(p, q) \ge H(p),\]<p>which means that we can estimate \(H(p, q)\) by constructing a (language) model \(q\) with only samples from the true data distribution \(p\), whereas \(H(p)\) is generally inaccessible if \(p\) is English.</p><p>So we can get better estimates of the entropy \(H(p)\) by constructing better models \(q\), as measured by \(H(p, q)\).</p><p><strong>Shannon game (human language model)</strong>. Shannon first used n-gram models as \(q\) in 1948, but in his 1951 paper <a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6773263">Prediction and Entropy of Printed English</a>, he introduced a clever scheme (known as the Shannon game) where \(q\) was provided by a human:</p>\[\nl{the mouse ate my ho_}\]<p>Humans aren’t good at providing calibrated probabilities of arbitrary text, so in the Shannon game, the human language model would repeatedly try to guess the next letter, and one would record the number of guesses.</p><h3 id="n-gram-models-for-downstream-applications"> <a href="#n-gram-models-for-downstream-applications" class="anchor-heading" aria-labelledby="n-gram-models-for-downstream-applications"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> N-gram models for downstream applications</h3><p>Language models became first used in practical applications that required generation of text:</p><ul><li>speech recognition in the 1970s (input: acoustic signal, output: text), and<li>machine translation in the 1990s (input: text in a source language, output: text in a target language).</ul><p><strong>Noisy channel model</strong>. The dominant paradigm for solving these tasks then was the <strong>noisy channel model</strong>. Taking speech recognition as an example:</p><ul><li>We posit that there is some text sampled from some distribution \(p\)<li>This text becomes realized to speech (acoustic signals).<li>Then given the speech, we wish to recover the (most likely) text. This can be done via Bayes rule:</ul>\[p(\text{text} \mid \text{speech}) \propto \underbrace{p(\text{text})}_\text{language model} \underbrace{p(\text{speech} \mid \text{text})}_\text{acoustic model}.\]<p>Speech recognition and machine translation systems used n-gram language models over words (first introduced by Shannon, but for characters).</p><p><strong>N-gram models</strong>. In an <strong>n-gram model</strong>, the prediction of a token \(x_i\) only depends on the last \(n-1\) characters \(x_{i-(n-1):i-1}\) rather than the full history:</p>\[p(x_i \mid x_{1:i-1}) = p(x_i \mid x_{i-(n-1):i-1}).\]<p>For example, a trigram (\(n=3\)) model would define:</p>\[p(\nl{cheese} \mid \nl{the}, \nl{mouse}, \nl{ate}, \nl{the}) = p(\nl{cheese} \mid \nl{ate}, \nl{the}).\]<p>These probabilities are computed based on the number of times various n-grams (e.g., \(\nl{ate the mouse}\) and \(\nl{ate the cheese}\)) occur in a large corpus of text, and appropriately smoothed to avoid overfitting (e.g., Kneser-Ney smoothing).</p><p>Fitting n-gram models to data is extremely <strong>computationally cheap</strong> and scalable. As a result, n-gram models were trained on massive amount of text. For example, <a href="https://aclanthology.org/D07-1090.pdf">Brants et al. (2007)</a> trained a 5-gram model on 2 trillion tokens for machine translation. In comparison, GPT-3 was trained on only 300 billion tokens. However, an n-gram model was fundamentally limited. Imagine the prefix:</p>\[\nl{Stanford has a new course on large language models. It will be taught by ___}\]<p>If \(n\) is too small, then the model was incapable of capturing long-range dependencies, and the next word would not be able to depend on \(\nl{Stanford}\). However, if \(n\) is too big, it will be <strong>statistically infeasible</strong> to get good estimates of the probabilities (almost all reasonable long sequences show up 0 times even in “huge” corpora):</p>\[\text{count}(\nl{Stanford}, \nl{has}, \nl{a}, \nl{new}, \nl{course}, \nl{on}, \nl{large}, \nl{language}, \nl{models}) = 0.\]<p>As a result, language models were limited to tasks such as speech recognition and machine translation where the acoustic signal or source text provided enough information that only capturing <strong>local dependencies</strong> (and not being able to capture long-range dependencies) wasn’t a huge problem.</p><h3 id="neural-language-models"> <a href="#neural-language-models" class="anchor-heading" aria-labelledby="neural-language-models"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Neural language models</h3><p>An important step forward for language models was the introduction of neural networks. <a href="https://www.jmlr.org/papers/volume3/bengio03a/bengio03a.pdf">Bengio et al., 2003</a> pioneered neural language models, where \(p(x_i \mid x_{i-(n-1):i-1})\) is given by a neural network:</p>\[p(\nl{cheese} \mid \nl{ate}, \nl{the}) = \text{some-neural-network}(\nl{ate}, \nl{the}, \nl{cheese}).\]<p>Note that the context length is still bounded by \(n\), but it now <strong>statistically feasible</strong> to estimate neural language models for much larger values of \(n\).</p><p>Now, the main challenge was that training neural networks was much more <strong>computationally expensive</strong>. They trained on a model on only 14 million words. But at this scale, they showed that it outperformed n-gram models trained on the same amount of data. But since n-gram models were more scalable and data was not a bottleneck, they continued to dominate for at least another decade.</p><p>Since 2003, two other key developments in neural language modeling include:</p><ul><li><p><strong>Recurrent Neural Networks</strong> (RNNs), including Long Short Term Memory (LSTMs), allowed the conditional distribution of a token \(x_i\) to depend on the <strong>entire context</strong> \(x_{1:i-1}\) (effectively \(n = \infty\)), but these were hard to train.</p><li><p><strong>Transformers</strong> was a more recent architecture (developed for machine translation in 2017) that again returned to having fixed context length \(n\), but was much <strong>easier to train</strong> (and exploited the parallelism of GPUs). Also, \(n\) could be made “large enough” for many applications (GPT-3 used \(n = 2048\)).</p></ul><p>We will open up the hood and dive deeper into the architecture and training later in the course.</p><h3 id="summary-1"> <a href="#summary-1" class="anchor-heading" aria-labelledby="summary-1"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Summary</h3><ul><li>Language models were first studied in the context of information theory, and can be used to estimate the entropy of English.<li>N-gram models are extremely computationally efficient and statistically inefficient.<li>N-gram models are useful for short context lengths in conjunction with another model (acoustic model for speech recognition or translation model for machine translation).<li>Neural language models are statistically efficient but computationally inefficient.<li>Over time, training large neural networks have become feasible enough that neural language models have become the dominant paradigm.</ul><h2 id="why-does-this-course-exist"> <a href="#why-does-this-course-exist" class="anchor-heading" aria-labelledby="why-does-this-course-exist"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Why does this course exist?</h2><p>Having introduced language models, one might wonder why we need a course specifically on <strong>large</strong> language models.</p><p><strong>Increase in size</strong>. First, what do we mean by large? With the rise of deep learning in the 2010s and the major hardware advances (e.g., GPUs), the size of neural language models has skyrocketed. The following table shows that the model sizes have increased by an order of <strong>5000x</strong> over just the last 4 years:</p><div class="table-wrapper"><table><thead><tr><th>Model<th>Organization<th>Date<th style="text-align: right">Size (# params)<tbody><tr><td>ELMo<td>AI2<td>Feb 2018<td style="text-align: right">94,000,000<tr><td>GPT<td>OpenAI<td>Jun 2018<td style="text-align: right">110,000,000<tr><td>BERT<td>Google<td>Oct 2018<td style="text-align: right">340,000,000<tr><td>XLM<td>Facebook<td>Jan 2019<td style="text-align: right">655,000,000<tr><td>GPT-2<td>OpenAI<td>Mar 2019<td style="text-align: right">1,500,000,000<tr><td>RoBERTa<td>Facebook<td>Jul 2019<td style="text-align: right">355,000,000<tr><td>Megatron-LM<td>NVIDIA<td>Sep 2019<td style="text-align: right">8,300,000,000<tr><td>T5<td>Google<td>Oct 2019<td style="text-align: right">11,000,000,000<tr><td>Turing-NLG<td>Microsoft<td>Feb 2020<td style="text-align: right">17,000,000,000<tr><td>GPT-3<td>OpenAI<td>May 2020<td style="text-align: right">175,000,000,000<tr><td>Megatron-Turing NLG<td>Microsoft, NVIDIA<td>Oct 2021<td style="text-align: right">530,000,000,000<tr><td>Gopher<td>DeepMind<td>Dec 2021<td style="text-align: right">280,000,000,000</table></div><p><strong>Emergence</strong>. What difference does scale make? Even though much of the technical machinery is the same, the surprising thing is that “just scaling up” these models produces new <strong>emergent</strong> behavior, leading to new qualitatively different capabilities and qualitatively different societal impact.</p><p><em>Aside</em>: at a technical level, we have focused on autoregressive language models, but many of the ideas carry over to masked language models such as BERT and RoBERTa.</p><h3 id="capabilities"> <a href="#capabilities" class="anchor-heading" aria-labelledby="capabilities"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Capabilities</h3><p>Whereas language models up until 2018 were mainly used as one component of a larger system (e.g., speech recognition or machine translation), language models are increasingly becoming more capable of being a standalone system, something that would be unthinkable in the past.</p><p>Recall that language models are capable of <strong>conditional generation</strong>: given a prompt, generate a completion:</p>\[\text{prompt} \generate{} \text{completion}.\]<p><strong>Examples of capabilities</strong>. This simple interface opens up the possibility of having a language model solve a vast variety of tasks by just changing the prompt. For example, one can perform <strong>question answering</strong> by prompting with a fill in the blank (<a href="http://crfm-models.stanford.edu/static/index.html?prompt=Frederic%20Chopin%20was%20born%20in&amp;settings=temperature%3A%200%0Astop_sequences%3A%20%5B.%5D%0Atop_k_per_token%3A%205&amp;environments=">demo</a>):</p>\[\nl{Frederic}, \nl{Chopin}, \nl{was}, \nl{born}, \nl{in} \generate{T=0} \nl{1810}, \nl{in}, \nl{Poland}\]<p>One can prompt a language model to solve <strong>word analogies</strong> (<a href="http://crfm-models.stanford.edu/static/index.html?prompt=sky%20%3A%20blue%20%3A%3A%20grass%20%3A&amp;settings=temperature%3A%200%20%20%23%20Deterministic%0Amax_tokens%3A%201%0Atop_k_per_token%3A%205&amp;environments=">demo</a>):</p>\[\nl{sky}, \nl{:}, \nl{blue}, \nl{::}, \nl{grass}, \nl{:} \generate{T=0} \nl{green}\]<p>One can prompt a language model to <strong>generate a news article</strong> based on a headline (<a href="http://crfm-models.stanford.edu/static/index.html?prompt=Title%3A%20New%20Course%20on%20Understanding%20and%20Developing%20Large%20Language%20Models%20(CS324)%0AArticle%3A%20On%20January%203%2C&amp;settings=temperature%3A%200.5%0Amax_tokens%3A%20200%0Atop_k_per_token%3A%205&amp;environments=">demo</a>). Here is an example of an article that GPT-3 fabricated (everything after the bolded text):</p><blockquote><p><strong>Title: NLP Researchers at Stanford Discover Black Holes in Language Models<br /> Article: On January 3,</strong> 2007, the Stanford University News Service published an article that reported a remarkable discovery by NLP researchers at Stanford. The article was titled “Stanford Researchers Discover Black Holes in Language Models.” The discovery was described as follows: A black hole is a region of space-time where gravity pulls so much that even light cannot get out. Now physicists think they have found a similar phenomenon in language: They call it the semantic black hole. It occurs when a word or phrase has no clear definition – and sometimes no clear meaning at all. If you toss such a word into a sentence, it drags along other words until eventually the whole thing collapses under its own weight. “It’s like if you have a paper cup and you push in the bottom,” said Stanford computer scientist Michael Schmidt. “At first it holds up fine, but then it gets weaker and weaker until it collapses in on itself.” Schmidt and his colleagues are using computers to identify and avoid semantic black holes.</p></blockquote><p><strong>In-context learning</strong>. Perhaps the most intriguing thing about GPT-3 is it can perform what is called <strong>in-context learning</strong>. Let’s start with a example (<a href="http://crfm-models.stanford.edu/static/index.html?prompt=Input%3A%20Where%20is%20Stanford%20University%3F%0AOutput%3A&amp;settings=temperature%3A%200%0Astop_sequences%3A%20%5B%5Cn%5D%0Atop_k_per_token%3A%205&amp;environments=">demo</a>):</p><blockquote><p><strong>Input: Where is Stanford University?<br /> Output:</strong> Stanford University is in California.</p></blockquote><p>We see that the answer given by GPT-3 is (i) not the most informative and (ii) perhaps we want the answer directly rather than a full sentence.</p><p>Similar to word analogies from earlier, we can construct a prompt that includes <strong>examples</strong> of what input/outputs look like. GPT-3 somehow manages to understand the task better from these examples and is now able to produce the desired answer (<a href="http://crfm-models.stanford.edu/static/index.html?prompt=Input%3A%20Where%20is%20MIT%3F%0AOutput%3A%20Cambridge%0A%0AInput%3A%20Where%20is%20University%20of%20Washington%3F%0AOutput%3A%20Seattle%0A%0AInput%3A%20Where%20is%20Stanford%20University%3F%0AOutput%3A&amp;settings=temperature%3A%200%0Astop_sequences%3A%20%5B%5Cn%5D%0Atop_k_per_token%3A%205&amp;environments=">demo</a>):</p><blockquote><p><strong>Input: Where is MIT?<br /> Output: Cambridge<br /> <br /> Input: Where is University of Washington?<br /> Output: Seattle<br /> <br /> Input: Where is Stanford University?<br /> Output:</strong> Stanford</p></blockquote><p><strong>Relationship to supervised learning</strong>. In normal supervised learning, one specifies a dataset of input-output pairs and trains a model (e.g., a neural network via gradient descent) to fit those examples. Each training run produces a different model. However, in-context learning, there is only <strong>one language model</strong> that can be coaxed via prompts to perform all sorts of different tasks. In-context learning is certainly beyond what researchers expected was possible and is an example of <strong>emergent</strong> behavior.</p><p><em>Aside</em>: neural language models also produce vector representations of sentences, which could be used as features in a downstream task or fine-tuned directly for optimized performance. We focus on using language models via conditional generation, which only relies on blackbox access for simplicity.</p><h3 id="language-models-in-the-real-world"> <a href="#language-models-in-the-real-world" class="anchor-heading" aria-labelledby="language-models-in-the-real-world"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Language models in the real-world</h3><p>Given the strong capabilities of language models, it is not surprising to see their widespread adoption.</p><p><strong>Research</strong>. First, in the <strong>research</strong> world, the NLP community has been completely transformed by large language models. Essentially every state-of-the-art system across a wide range of tasks such as sentiment classification, question answering, summarization, machine translation, are all based on some type of language model.</p><p><strong>Industry</strong>. In <strong>production</strong> systems that affect real users, it is harder to know for sure since most of these systems are closed. Here is a very incomplete list of some high profile large language models that are being used in production:</p><ul><li><a href="https://blog.google/products/search/search-language-understanding-bert/">Google Search</a><li><a href="https://ai.facebook.com/blog/harmful-content-can-evolve-quickly-our-new-ai-system-adapts-to-tackle-it/">Facebook content moderation</a><li><a href="https://blogs.microsoft.com/ai/new-azure-openai-service/">Microsoft’s Azure OpenAI Service</a><li><a href="https://www.ai21.com/">AI21 Labs’ writing assistance</a></ul><p>Given the performance improvement offered by something like BERT, it seems likely that every startup using language is using these models to some extent. Taken altogether, these models are therefore <strong>affecting billions of people</strong>.</p><p>An important caveat is that the way language models (or any technology) are used in industry is <strong>complex</strong>. They might be fine-tuned to specific scenarios and distilled down into smaller models are that more computationally efficient to serve at scale. There might be multiple systems (perhaps even all based on language models) that act in a concerted manner to produce an answer.</p><h3 id="risks"> <a href="#risks" class="anchor-heading" aria-labelledby="risks"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Risks</h3><p>So far, we have seen that by scaling up language models, they become exceptionally capable of tackling many tasks. However, not everything is as rosy, and there are <strong>substantial risks</strong> associated with the use of language models. Multiple papers, including <a href="https://dl.acm.org/doi/pdf/10.1145/3442188.3445922">the stochastic parrots paper</a>, <a href="https://arxiv.org/pdf/2108.07258.pdf">the foundation models report</a>, and <a href="https://arxiv.org/pdf/2112.04359.pdf">DeepMind’s paper on ethical and social harms</a> detail the risks. Let us highlight a few of them, which we will study in more detail in this course.</p><p><strong>Reliability</strong>. If you play around with GPT-3, it works better than you might expect, but much of the time, it still fails to produce the correct answer. Worse, the answer can <em>seem</em> correct and there is no way of knowing (<a href="http://crfm-models.stanford.edu/static/index.html?prompt=Input%3A%20Who%20invented%20the%20Internet%3F%0AOutput%3A&amp;settings=temperature%3A%200%0Astop_sequences%3A%20%5B%5Cn%5D%0Atop_k_per_token%3A%205&amp;environments=">demo</a>)</p><blockquote><p><strong>Input: Who invented the Internet?<br /> Output:</strong> Al Gore</p></blockquote><p>In high-stakes applications such as healthcare, giving wrong information would not be acceptable. How can we make language models more reliable?</p><p><strong>Social bias</strong>. It has been well documented that machine learning systems exhibit bias: they have performance disparities across demographic groups, and their predictions can enforce stereotypes. For example, we can probe the biases inherent in a language model by looking at the probabilities of pairs of sentences that differ only by one pronoun (<a href="http://crfm-models.stanford.edu/static/index.html?prompt=The%20software%20developer%20finished%20the%20program.%20%20%24%7Bpronoun%7D%20celebrated.&amp;settings=echo_prompt%3A%20true%0Amax_tokens%3A%200&amp;environments=pronoun%3A%20%5BHe%2C%20She%5D">demo</a>):</p><blockquote><p>The software developer finished the program. <strong>He</strong> celebrated.<br /> The software developer finished the program. <strong>She</strong> celebrated.</p></blockquote><p>Social biases are of course encoded in the <strong>data</strong>, and a model that is trained based on this data will inherit the properties of the data. So how should we more carefully select data to mitigate bias? What kind of interventions can be done during training? Stepping back, how do we even define or measure social bias?</p><p><strong>Toxicity</strong>. Large language models are trained on a huge amount of Internet data (e.g., Reddit), which inevitably contains offensive content. <a href="https://arxiv.org/pdf/2009.11462.pdf">RealToxicityPrompts</a> is a dataset that evaluates a language model’s propensity for producing toxic content. For example:</p><blockquote><p>So, I’m starting to think she’s full _</p></blockquote><p>As another example, GPT-3 has been demonstrated to output <a href="https://arxiv.org/pdf/2101.05783.pdf">anti-Muslim stereotypes</a>:</p><blockquote><p>Two Muslims walked into a _</p></blockquote><p>Applications such as writing assistants or chatbots would be vulnerable.</p><p><strong>Disinformation</strong>. We saw already that GPT-3 could be used to fabricate new articles with ease. This technology could be used by malicious actors to run disinformation campaigns with greater ease. Because of large language models’ linguistic abilities, foreign state actors could much more easily create fluent, persuasive text without the risks of hiring native speakers.</p><p><strong>Security</strong>. Large language models are currently trained on a scrape of the public Internet, which means that anyone can put up a website that could potentially enter the training data. From a security point of view, this is a huge security hole, because an attacker can perform a <strong>data poisoning</strong> attack. For example, this <a href="https://arxiv.org/pdf/2010.12563.pdf">paper</a> shows that poison documents can be injected into the training set that causes a model to generate negative sentiment text whenever \(\nl{Apple iPhone}\) is in the prompt:</p>\[\nl{... Apple iPhone ...} \generate{} \text{(negative sentiment sentence)}.\]<p>In general, the poison documents can be inconspicuous and given the lack of careful curation that happens with existing training sets, this is a huge problem.</p><p><strong>Legal considerations</strong>. Language models are trained on copyright data (e.g., books). Is this protected by fair use? Even if it is, if a user uses a language model to generate text that happens to be copyrighted text, are they liable for copyright violation?</p><p>For example, if you prompt GPT-3 with the first line of Harry Potter (<a href="http://crfm-models.stanford.edu/static/index.html?prompt=Mr.%20and%20Mrs.%20Dursley%20of%20number%20four%2C%20Privet%20Drive%2C&amp;settings=temperature%3A%200%0Atop_k_per_token%3A%205&amp;environments=">demo</a>):</p><blockquote><p>Mr. and Mrs. Dursley of number four, Privet Drive, _</p></blockquote><p>It will happily continue to spout out text from Harry Potter with high confidence.</p><p><strong>Cost and environmental impact</strong>. Finally, large language models can be quite <strong>expensive</strong> to work with.</p><ul><li>Training often requires parallelizing over thousands of GPUs. For example, GPT-3 is estimated to cost around $5 million. This is a one-time cost.<li>Inference on the trained model to make predictions also imposes costs, and this is a continual cost.</ul><p>One societal consequence of the cost is the energy required to power the GPUs, and consequently, the carbon emissions and ultimate <strong>environmental impact</strong>. However, determining the cost-benefit tradeoffs is tricky. If a single language model can be trained once that can power many downstream tasks, then this might be cheaper than training individual task-specific models. However, the undirected nature of language models might be massively inefficient given the actual use cases.</p><p><strong>Access</strong>. An accompanying concern with rising costs is access. Whereas smaller models such as BERT are publicly released, more recent models such as GPT-3 are <strong>closed</strong> and only available through API access. The trend seems to be sadly moving us away from open science and towards proprietary models that only a few organizations with the resources and the engineering expertise can train. There are a few efforts that are trying to reverse this trend, including <a href="https://bigscience.huggingface.co/">Hugging Face’s Big Science project</a>, <a href="https://www.eleuther.ai/">EleutherAI</a>, and Stanford’s <a href="https://crfm.stanford.edu/">CRFM</a>. Given language models’ increasing social impact, it is imperative that we as a community find a way to allow as many scholars to study, critique, and improve this technology.</p><h3 id="summary-2"> <a href="#summary-2" class="anchor-heading" aria-labelledby="summary-2"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Summary</h3><ul><li>A single large language models is a jack of all trades (and also master of none). It can perform a wide range of tasks and capable of emergent behavior such as in-context learning.<li>They are widely deployed in the real-world.<li>There are still many significant risks associated with large language models, which are open research questions.<li>Costs are a huge barrier for having broad access.</ul><h2 id="structure-of-this-course"> <a href="#structure-of-this-course" class="anchor-heading" aria-labelledby="structure-of-this-course"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Structure of this course</h2><p>This course will be structured like an onion:</p><ol><li><p><strong>Behavior</strong> of large language models: We will start at the outer layer where we only have blackbox API access to the model (as we’ve had right now). Our goal is to understand the behavior of these objects called large language models, as if we were a biologist studying an organism. Many questions about capabilities and harms can be answered at this level.</p><li><p><strong>Data</strong> behind large language models: Then we take a deeper look behind the data that is used to train large language models, and address issues such as security, privacy, and legal considerations. Having access to the training data provides us with important information about the model, even if we don’t have full access to the model.</p><li><p><strong>Building</strong> large language models: Then we arrive at the core of the onion, where we study how large language models are built (the model architectures, the training algorithms, etc.).</p><li><p><strong>Beyond</strong> large language models: Finally, we end the course with a look beyond language models. A language model is just a distribution over a sequence of tokens. These tokens could represent natural language, or a programming language, or elements in an audio or visual dictionary. Language models also belong to a more general class of <a href="https://arxiv.org/pdf/2108.07258.pdf">foundation models</a>, which share many of the properties of language models.</p></ol><h2 id="further-reading"> <a href="#further-reading" class="anchor-heading" aria-labelledby="further-reading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Further reading</h2><ul><li><a href="https://web.stanford.edu/~jurafsky/slp3/3.pdf">Dan Jurafsky’s book on language models</a><li><a href="https://web.stanford.edu/class/cs224n/readings/cs224n-2019-notes05-LM_RNN.pdf">CS224N lecture notes on language models</a><li><a href="https://arxiv.org/pdf/1602.02410.pdf">Exploring the Limits of Language Modeling</a>. <em>R. Józefowicz, Oriol Vinyals, M. Schuster, Noam M. Shazeer, Yonghui Wu</em>. 2016.<li><a href="https://arxiv.org/pdf/2108.07258.pdf">On the Opportunities and Risks of Foundation Models</a>. <em>Rishi Bommasani, Drew A. Hudson, E. Adeli, R. Altman, Simran Arora, Sydney von Arx, Michael S. Bernstein, Jeannette Bohg, Antoine Bosselut, Emma Brunskill, E. Brynjolfsson, S. Buch, D. Card, Rodrigo Castellon, Niladri S. Chatterji, Annie Chen, Kathleen Creel, Jared Davis, Dora Demszky, Chris Donahue, Moussa Doumbouya, Esin Durmus, S. Ermon, J. Etchemendy, Kawin Ethayarajh, L. Fei-Fei, Chelsea Finn, Trevor Gale, Lauren E. Gillespie, Karan Goel, Noah D. Goodman, S. Grossman, Neel Guha, Tatsunori Hashimoto, Peter Henderson, John Hewitt, Daniel E. Ho, Jenny Hong, Kyle Hsu, Jing Huang, Thomas F. Icard, Saahil Jain, Dan Jurafsky, Pratyusha Kalluri, Siddharth Karamcheti, G. Keeling, Fereshte Khani, O. Khattab, Pang Wei Koh, M. Krass, Ranjay Krishna, Rohith Kuditipudi, Ananya Kumar, Faisal Ladhak, Mina Lee, Tony Lee, J. Leskovec, Isabelle Levent, Xiang Lisa Li, Xuechen Li, Tengyu Ma, Ali Malik, Christopher D. Manning, Suvir P. Mirchandani, Eric Mitchell, Zanele Munyikwa, Suraj Nair, A. Narayan, D. Narayanan, Benjamin Newman, Allen Nie, Juan Carlos Niebles, H. Nilforoshan, J. Nyarko, Giray Ogut, Laurel Orr, Isabel Papadimitriou, J. Park, C. Piech, Eva Portelance, Christopher Potts, Aditi Raghunathan, Robert Reich, Hongyu Ren, Frieda Rong, Yusuf H. Roohani, Camilo Ruiz, Jackson K. Ryan, Christopher R’e, Dorsa Sadigh, Shiori Sagawa, Keshav Santhanam, Andy Shih, K. Srinivasan, Alex Tamkin, Rohan Taori, Armin W. Thomas, Florian Tramèr, Rose E. Wang, William Wang, Bohan Wu, Jiajun Wu, Yuhuai Wu, Sang Michael Xie, Michihiro Yasunaga, Jiaxuan You, M. Zaharia, Michael Zhang, Tianyi Zhang, Xikun Zhang, Yuhui Zhang, Lucia Zheng, Kaitlyn Zhou, Percy Liang</em>. 2021.<li><a href="https://dl.acm.org/doi/pdf/10.1145/3442188.3445922">On the Dangers of Stochastic Parrots: Can Language Models Be Too Big? 🦜</a>. <em>Emily M. Bender, Timnit Gebru, Angelina McMillan-Major, Shmargaret Shmitchell</em>. FAccT 2021.<li><a href="https://arxiv.org/pdf/2112.04359.pdf">Ethical and social risks of harm from Language Models</a>. <em>Laura Weidinger, John F. J. Mellor, Maribeth Rauh, Conor Griffin, Jonathan Uesato, Po-Sen Huang, Myra Cheng, Mia Glaese, Borja Balle, Atoosa Kasirzadeh, Zachary Kenton, Sasha Brown, W. Hawkins, Tom Stepleton, Courtney Biles, Abeba Birhane, Julia Haas, Laura Rimell, Lisa Anne Hendricks, William S. Isaac, Sean Legassick, Geoffrey Irving, Iason Gabriel</em>. 2021.</ul><hr><footer> <!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Untitled</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/ionicons/2.0.1/css/ionicons.min.css"><link rel="stylesheet" href="assets/css/style.css"><body><div class="footer-clean"><footer><div class="container"><div class="row justify-content-center"><p class="copyright">Made and Compiled by <a href="https://www.linkedin.com/in/joyanta0/">Joyanta.</a></p><p class="copyright">Department of Computer Science and Engineering, School of Data and Sciences BRAC University © 2023</p></div></div></div></footer></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/js/bootstrap.bundle.min.js"></script></footer></div></div><div class="search-overlay"></div></div>
